<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Over the Board Chess</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      margin: 20px;
    }
    h1 {
      margin-bottom: 10px;
    }
    #game-options label,
    #game-options select {
      font-size: 16px;
      margin-right: 10px;
    }
    #chessboard {
      margin: 0 auto;
      display: inline-block;
    }
    table {
      border-collapse: collapse;
    }
    td {
      width: 60px;
      height: 60px;
      vertical-align: middle;
      text-align: center;
      font-size: 42px;
      cursor: pointer;
      user-select: none;
    }
    .dark {
      background-color: #b58863;
    }
    .light {
      background-color: #f0d9b5;
    }
    .selected {
      outline: 3px solid red;
    }
    #status {
      margin-top: 15px;
      font-size: 20px;
    }
    #resetButton {
      margin-top: 10px;
      padding: 5px 15px;
      font-size: 16px;
    }
  </style>
</head>
<body>
  <h1>Over the Board Chess</h1>

  <!-- Game Options -->
  <div id="game-options">
    <label for="modeSelect">Game Mode:</label>
    <select id="modeSelect">
      <option value="twoplayer">Two Player</option>
      <option value="stockfish">Play Against Stockfish</option>
      <option value="losing">Losing Mode (Stockfish tries to lose)</option>
      <option value="enginevengine">Engine vs Engine</option>
    </select>

    <!-- Single Engine Difficulty (for standard single-player) -->
    <span id="single-difficulty" style="display:none;">
      <label for="difficultySelect">Difficulty:</label>
      <select id="difficultySelect">
        <!-- Stockfish Skill Level: 0 (weakest) to 20 (strongest) -->
        <option value="0">0 (Weakest)</option>
        <option value="1">1</option>
        <option value="2">2</option>
        <option value="3">3</option>
        <option value="4">4</option>
        <option value="5" selected>5 (Medium)</option>
        <option value="6">6</option>
        <option value="7">7</option>
        <option value="8">8</option>
        <option value="9">9</option>
        <option value="10">10 (Strong)</option>
        <option value="11">11</option>
        <option value="12">12</option>
        <option value="13">13</option>
        <option value="14">14</option>
        <option value="15">15</option>
        <option value="16">16</option>
        <option value="17">17</option>
        <option value="18">18</option>
        <option value="19">19</option>
        <option value="20">20 (Strongest)</option>
      </select>
    </span>

    <!-- Engine vs Engine Difficulty selectors -->
    <span id="engine-levels" style="display:none;">
      <label for="whiteDifficultySelect">White Skill:</label>
      <select id="whiteDifficultySelect">
        <option value="0">0</option>
        <option value="1">1</option>
        <option value="2">2</option>
        <option value="3">3</option>
        <option value="4">4</option>
        <option value="5" selected>5</option>
        <option value="6">6</option>
        <option value="7">7</option>
        <option value="8">8</option>
        <option value="9">9</option>
        <option value="10">10</option>
        <option value="11">11</option>
        <option value="12">12</option>
        <option value="13">13</option>
        <option value="14">14</option>
        <option value="15">15</option>
        <option value="16">16</option>
        <option value="17">17</option>
        <option value="18">18</option>
        <option value="19">19</option>
        <option value="20">20</option>
      </select>

      <label for="blackDifficultySelect">Black Skill:</label>
      <select id="blackDifficultySelect">
        <option value="0">0</option>
        <option value="1">1</option>
        <option value="2">2</option>
        <option value="3">3</option>
        <option value="4">4</option>
        <option value="5" selected>5</option>
        <option value="6">6</option>
        <option value="7">7</option>
        <option value="8">8</option>
        <option value="9">9</option>
        <option value="10">10</option>
        <option value="11">11</option>
        <option value="12">12</option>
        <option value="13">13</option>
        <option value="14">14</option>
        <option value="15">15</option>
        <option value="16">16</option>
        <option value="17">17</option>
        <option value="18">18</option>
        <option value="19">19</option>
        <option value="20">20</option>
      </select>
    </span>
  </div>

  <!-- Chessboard and Status -->
  <div id="chessboard"></div>
  <div id="status"></div>
  <button id="resetButton">Reset Game</button>

  <!-- Include chess.js via CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
  
  <script>
    // Global Variables
    var game = new Chess();
    var selectedSquare = null;
    var boardDiv = document.getElementById("chessboard");
    var isSinglePlayerMode = false; // For modes where a human plays vs an engine.
    var currentMode = "twoplayer"; // Options: 'twoplayer', 'stockfish', 'losing', 'enginevengine'
    var humanColor = 'w'; // In single‑player modes, human is white by default.
    var files = ['a','b','c','d','e','f','g','h'];

    // Stockfish Workers
    var stockfish = null;          // Used for single‑player mode ("stockfish")
    var stockfishWhite = null;     // Used for engine vs engine mode (white side)
    var stockfishBlack = null;     // Used for engine vs engine mode (black side)

    /* ----------------------- Board and Rendering ----------------------- */
    function createBoard() {
      var table = document.createElement("table");
      for (var i = 0; i < 8; i++) {
        var row = document.createElement("tr");
        var rank = 8 - i;
        for (var j = 0; j < 8; j++) {
          var cell = document.createElement("td");
          var file = files[j];
          var square = file + rank;
          cell.id = square;
          cell.className = ((i + j) % 2 === 0) ? "dark" : "light";
          cell.addEventListener("click", onCellClick);
          row.appendChild(cell);
        }
        table.appendChild(row);
      }
      boardDiv.innerHTML = "";
      boardDiv.appendChild(table);
    }
    
    function drawBoard() {
      var boardState = game.board();
      for (var i = 0; i < 8; i++) {
        var rank = 8 - i;
        for (var j = 0; j < 8; j++) {
          var cell = document.getElementById(files[j] + rank);
          var piece = boardState[i][j];
          cell.innerHTML = piece ? getUnicode(piece) : "";
          cell.classList.remove("selected");
        }
      }
      updateStatus();
    }

    // Map chess pieces to Unicode characters.
    function getUnicode(piece) {
      var unicode = {
        'p': {'w': '♙', 'b': '♟'},
        'r': {'w': '♖', 'b': '♜'},
        'n': {'w': '♘', 'b': '♞'},
        'b': {'w': '♗', 'b': '♝'},
        'q': {'w': '♕', 'b': '♛'},
        'k': {'w': '♔', 'b': '♚'}
      };
      return unicode[piece.type][piece.color];
    }
    
    function updateStatus() {
      var statusDiv = document.getElementById("status");
      var status = "";
      if (game.in_checkmate()) {
        status = "Game over: " + (game.turn() === 'w' ? "Black" : "White") + " wins by checkmate.";
      } else if (game.in_draw()) {
        status = "Game over: drawn position.";
      } else {
        status = (game.turn() === 'w' ? "White" : "Black") + " to move.";
        if (game.in_check()) status += " Check!";
      }
      statusDiv.textContent = status;
    }

    /* ----------------------- Move Handling ----------------------- */
    function onCellClick(e) {
      // In engine vs engine mode, disable human moves.
      if (currentMode === "enginevengine") return;
      var square = e.currentTarget.id;
      if (!selectedSquare) {
        var piece = game.get(square);
        if (piece && piece.color === game.turn()) {
          // In single‑player modes, only allow the human to move his own pieces.
          if ((currentMode === "stockfish" || currentMode === "losing") && piece.color !== humanColor) return;
          selectedSquare = square;
          e.currentTarget.classList.add("selected");
        }
      } else {
        if (selectedSquare === square) {
          e.currentTarget.classList.remove("selected");
          selectedSquare = null;
          return;
        }
        var move = game.move({ from: selectedSquare, to: square, promotion: 'q' });
        if (move === null) {
          alert("Invalid move!");
        }
        selectedSquare = null;
        drawBoard();
        // After a human move, if in a single‑player mode, let the engine make its move.
        if ((currentMode === "stockfish" || currentMode === "losing") && game.turn() !== humanColor && !game.game_over()) {
          if (currentMode === "stockfish") {
            setTimeout(function() { askEngineForMove(game.fen()); }, 250);
          } else if (currentMode === "losing") {
            setTimeout(function() {
              var engineMove = chooseLosingMove();
              if (engineMove) {
                game.move({ from: engineMove.from, to: engineMove.to, promotion: 'q' });
              }
              drawBoard();
            }, 250);
          }
        }
      }
    }
    
    /* ----------------------- Stockfish Integration (Standard) ----------------------- */
    function initStockfish() {
      if (typeof(Worker) === "undefined") {
        console.error("Your browser does not support Web Workers.");
        return;
      }
      if (!stockfish) {
        stockfish = new Worker('stockfish.js');
        stockfish.onmessage = function(e) {
          var msg = e.data;
          console.log("Stockfish:", msg);
          if (msg.indexOf("bestmove") === 0) {
            var tokens = msg.split(" ");
            var bestMove = tokens[1];
            if (bestMove && bestMove !== "(none)") {
              game.move({
                from: bestMove.substring(0, 2),
                to: bestMove.substring(2, 4),
                promotion: 'q'
              });
              drawBoard();
            }
          }
        };
        stockfish.postMessage("uci");
        setTimeout(updateSingleEngineDifficulty, 500);
      } else {
        updateSingleEngineDifficulty();
      }
    }
    
    function updateSingleEngineDifficulty() {
      var diffSelect = document.getElementById("difficultySelect");
      var diff = diffSelect.value;
      stockfish.postMessage("setoption name Skill Level value " + diff);
    }
    
    function askEngineForMove(fen) {
      if (!stockfish) {
        console.error("Stockfish engine not initialized.");
        return;
      }
      stockfish.postMessage("position fen " + fen);
      stockfish.postMessage("go movetime 500");
    }
    
    /* ----------------------- Losing Mode ----------------------- */
    // A simple evaluation based solely on material counts.
    function evaluateBoardForColor(gameInstance, color) {
      var values = { p: 1, n: 3, b: 3, r: 5, q: 9, k: 0 };
      var board = gameInstance.board();
      var score = 0;
      for (var i = 0; i < board.length; i++) {
        for (var j = 0; j < board[i].length; j++) {
          var piece = board[i][j];
          if (piece) {
            var val = values[piece.type];
            score += (piece.color === color ? val : -val);
          }
        }
      }
      return score;
    }
    
    // Choose the move that gives the worst material evaluation for the engine.
    function chooseLosingMove() {
      var moves = game.moves({ verbose: true });
      if (moves.length === 0) return null;
      var worstMove = null;
      var worstScore = Infinity;
      // In these single‑player modes, the engine is the non‑human (human is white by default).
      var engineColor = (humanColor === 'w') ? 'b' : 'w';
      for (var i = 0; i < moves.length; i++) {
        var move = moves[i];
        // Clone the current game state.
        var clone = new Chess(game.fen());
        clone.move(move);
        var score = evaluateBoardForColor(clone, engineColor);
        // For engine trying to lose, choose the move that results in the lowest score.
        if (score < worstScore) {
          worstScore = score;
          worstMove = move;
        }
      }
      return worstMove;
    }
    
    /* ----------------------- Engine vs Engine Mode ----------------------- */
    var stockfishWhite = null;
    var stockfishBlack = null;
    
    function initEngineVsEngine() {
      // If a single-engine worker exists, terminate it.
      if (stockfish) {
        stockfish.terminate();
        stockfish = null;
      }
      if (typeof(Worker) === "undefined") {
        console.error("Your browser does not support Web Workers.");
        return;
      }
      // Initialize Stockfish for White.
      if (!stockfishWhite) {
        stockfishWhite = new Worker('stockfish.js');
        stockfishWhite.onmessage = function(e) {
          var msg = e.data;
          if (msg.indexOf("bestmove") === 0) {
            var tokens = msg.split(" ");
            var bestMove = tokens[1];
            if (bestMove && bestMove !== "(none)" && game.turn() === 'w') {
              game.move({
                from: bestMove.substring(0,2),
                to: bestMove.substring(2,4),
                promotion: 'q'
              });
              drawBoard();
              setTimeout(autoPlayEngineVsEngine, 250);
            }
          }
        };
        stockfishWhite.postMessage("uci");
        setTimeout(function(){ updateEngineDifficulty('w'); },500);
      } else {
        updateEngineDifficulty('w');
      }
      
      // Initialize Stockfish for Black.
      if (!stockfishBlack) {
        stockfishBlack = new Worker('stockfish.js');
        stockfishBlack.onmessage = function(e) {
          var msg = e.data;
          if (msg.indexOf("bestmove") === 0) {
            var tokens = msg.split(" ");
            var bestMove = tokens[1];
            if (bestMove && bestMove !== "(none)" && game.turn() === 'b') {
              game.move({
                from: bestMove.substring(0,2),
                to: bestMove.substring(2,4),
                promotion: 'q'
              });
              drawBoard();
              setTimeout(autoPlayEngineVsEngine, 250);
            }
          }
        };
        stockfishBlack.postMessage("uci");
        setTimeout(function(){ updateEngineDifficulty('b'); },500);
      } else {
        updateEngineDifficulty('b');
      }
      autoPlayEngineVsEngine();
    }
    
    function updateEngineDifficulty(side) {
      if (side === 'w') {
        var level = document.getElementById("whiteDifficultySelect").value;
        stockfishWhite.postMessage("setoption name Skill Level value " + level);
      } else if (side === 'b') {
        var level = document.getElementById("blackDifficultySelect").value;
        stockfishBlack.postMessage("setoption name Skill Level value " + level);
      }
    }
    
    function autoPlayEngineVsEngine() {
      if (game.game_over()) {
        updateStatus();
        return;
      }
      var fen = game.fen();
      if (game.turn() === 'w') {
        stockfishWhite.postMessage("position fen " + fen);
        stockfishWhite.postMessage("go movetime 500");
      } else if (game.turn() === 'b') {
        stockfishBlack.postMessage("position fen " + fen);
        stockfishBlack.postMessage("go movetime 500");
      }
    }
    
    /* ----------------------- UI Mode Handling ----------------------- */
    document.getElementById("modeSelect").addEventListener("change", function(e) {
      currentMode = e.target.value;
      // Show/hide difficulty selectors based on mode.
      if (currentMode === "stockfish") {
        isSinglePlayerMode = true;
        humanColor = 'w';
        document.getElementById("single-difficulty").style.display = "inline";
        document.getElementById("engine-levels").style.display = "none";
        initStockfish();
      } else if (currentMode === "losing") {
        isSinglePlayerMode = true;
        humanColor = 'w';
        document.getElementById("single-difficulty").style.display = "none";
        document.getElementById("engine-levels").style.display = "none";
      } else if (currentMode === "enginevengine") {
        isSinglePlayerMode = false;
        document.getElementById("single-difficulty").style.display = "none";
        document.getElementById("engine-levels").style.display = "inline";
        initEngineVsEngine();
      } else { // Two Player
        isSinglePlayerMode = false;
        humanColor = null;
        document.getElementById("single-difficulty").style.display = "none";
        document.getElementById("engine-levels").style.display = "none";
      }
      resetGame();
    });
    
    // Update difficulty for engine vs engine when selectors change.
    document.getElementById("whiteDifficultySelect").addEventListener("change", function(){
      if (currentMode === "enginevengine" && stockfishWhite) {
        updateEngineDifficulty('w');
      }
    });
    document.getElementById("blackDifficultySelect").addEventListener("change", function(){
      if (currentMode === "enginevengine" && stockfishBlack) {
        updateEngineDifficulty('b');
      }
    });
    
    /* ----------------------- Game Reset ----------------------- */
    function resetGame() {
      game.reset();
      selectedSquare = null;
      drawBoard();
      // In engine vs engine mode, restart auto play.
      if (currentMode === "enginevengine") {
        setTimeout(autoPlayEngineVsEngine, 250);
      }
    }
    
    document.getElementById("resetButton").addEventListener("click", function() {
      resetGame();
    });
    
    // Initialize the board on load.
    createBoard();
    drawBoard();
  </script>
</body>
</html>
