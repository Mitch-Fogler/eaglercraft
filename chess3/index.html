<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Mitch's Sigma Chess</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    h1 { text-align: center; margin-bottom: 10px; }
    #game-options { text-align: center; margin-bottom: 10px; }
    #status { text-align: center; margin-top: 15px; font-size: 20px; }
    #version { text-align: center; font-size: 10px; margin-top: 10px; }

    #board-container { display: flex; justify-content: center; align-items: flex-start; }
    #analysis-panel {
      width: 260px; margin-left: 10px; font-size: 14px; line-height: 1.3;
      display: none;
    }
    #analysis-panel button,
    #analysis-panel select,
    #analysis-panel input { margin: 4px 0; font-size: 14px; }

    #chessboard { margin: 0; }
    table { border-collapse: collapse; }
    td {
      width: 60px; height: 60px;
      text-align: center; vertical-align: middle;
      font-size: 42px; cursor: pointer; user-select: none;
    }
    .light { background: #f0d9b5; }
    .dark  { background: #b58863; }
    .selected { outline: 3px solid red; }

    #pv-list { max-height: 300px; overflow-y: auto; padding: 0; list-style: none; margin: 4px 0; }
    #pv-list li { padding: 2px 4px; cursor: pointer; }
    #pv-list li:hover { background: #eef; }
    #pv-list .pv-header { font-weight: bold; }
  </style>
</head>
<body>
  <h1>Mitch's Sigma Chess</h1>

  <div id="game-options">
    <label>Mode:</label>
    <select id="modeSelect">
      <option value="twoplayer">Two Player</option>
      <option value="stockfish">vs Stockfish</option>
      <option value="losing">Losing Mode</option>
      <option value="enginevengine">Engine vs Engine</option>
      <option value="setup">Setup Position</option>
      <option value="analysis">Analysis</option>
    </select>
  </div>

  <div id="board-container">
    <div id="chessboard"></div>
    <div id="analysis-panel">
      <div>
        <button id="stopAnalysis" disabled>Stop</button>
        <button id="hideAnalysis">Hide</button>
      </div>
      <div>
        <label>Depth:</label>
        <select id="depthSelect">
          <option>8</option><option>10</option><option>12</option><option>14</option>
          <option selected>16</option><option>18</option><option>20</option>
        </select>
      </div>
      <div>
        <label>#Lines:</label>
        <button id="decreaseLines">–</button>
        <span id="linesCount">3</span>
        <button id="increaseLines">+</button>
      </div>
      <div><label>Eval:</label> <span id="numericEval">0.00</span></div>
      <ul id="pv-list">
        <li class="pv-header">Principal Variations:</li>
      </ul>
      <hr>
      <div>
        <button id="importFEN">Import FEN</button>
        <button id="importPGN">Import PGN</button>
      </div>
      <div>
        <button id="setupPosition">Setup</button>
        <button id="playPosition">Play</button>
      </div>
    </div>
  </div>

  <div id="status"></div>
  <div id="version">v.1.8</div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
  <script>
    // Globals
    const game = new Chess();
    const files = ['a','b','c','d','e','f','g','h'];
    let mode = 'twoplayer', humanColor='w', customFEN=null;
    let selectedSquare=null;
    let engine=null, isAnalyzing=false, pvCount=3;

    // Build board
    function createBoard(){
      const d=document.getElementById('chessboard');
      let html='<table>';
      for(let r=8;r>=1;r--){
        html+='<tr>';
        for(let f=0;f<8;f++){
          const sq=files[f]+r;
          html+=`<td id="${sq}" class="${(f+r)%2?'light':'dark'}"></td>`;
        }
        html+='</tr>';
      }
      html+='</table>';
      d.innerHTML=html;
      document.querySelectorAll('#chessboard td').forEach(td=>{
        td.onclick=onCellClick;
      });
    }

    // Draw pieces
    function drawBoard(){
      const b=game.board();
      for(let r=8;r>=1;r--){
        for(let f=0;f<8;f++){
          const sq=files[f]+r, td=document.getElementById(sq);
          const p=b[8-r][f];
          td.textContent = p? unicode(p):'';
          td.classList.remove('selected');
        }
      }
      updateStatus();
    }

    function unicode(p){
      const m={p:{w:'♙',b:'♟'},r:{w:'♖',b:'♜'},
               n:{w:'♘',b:'♞'},b:{w:'♗',b:'♝'},
               q:{w:'♕',b:'♛'},k:{w:'♔',b:'♚'}};
      return m[p.type][p.color];
    }

    // Status
    function updateStatus(){
      let s='';
      if(game.in_checkmate()){
        s=`Game over: ${game.turn()==='w'?'Black':'White'} wins.`;
      } else if(game.in_draw()){
        s='Game over: drawn.';
      } else {
        s=`${game.turn()==='w'?'White':'Black'} to move.` + (game.in_check()?' Check!':'');
      }
      document.getElementById('status').textContent=s;
    }

    // Cell click
    function onCellClick(e){
      const sq=e.target.id;
      if(mode==='analysis' || mode==='setup'){
        boardSetupMode(sq);
        return;
      }
      if(mode==='enginevengine') return;
      if(!selectedSquare){
        const pc=game.get(sq);
        if(!pc||pc.color!==game.turn()) return;
        if((mode==='stockfish'||mode==='losing') && pc.color!==humanColor) return;
        selectedSquare=sq; e.target.classList.add('selected');
      } else {
        if(sq===selectedSquare){
          e.target.classList.remove('selected');
          selectedSquare=null; return;
        }
        let promo='q', pc=game.get(selectedSquare);
        if(pc && pc.type==='p' &&
           ((pc.color==='w'&&sq.endsWith('8'))||(pc.color==='b'&&sq.endsWith('1')))){
          const c=prompt('Promote to (q,r,b,n):','q');
          if(c&&'qrbn'.includes(c.toLowerCase())) promo=c;
        }
        const mv=game.move({from:selectedSquare,to:sq,promotion:promo});
        if(!mv) alert('Invalid');
        selectedSquare=null;
        drawBoard();
        if((mode==='stockfish'||mode==='losing') && !game.game_over() && game.turn()!==humanColor){
          setTimeout(()=>engineMove(),200);
        }
      }
    }

    // Mode switch
    document.getElementById('modeSelect').onchange=()=>{
      mode=document.getElementById('modeSelect').value;
      document.getElementById('analysis-panel').style.display=mode==='analysis'?'block':'none';
      if(mode==='analysis') startAnalysis(); else stopAnalysis();
      resetGame();
    };

    // Engine move
    function engineMove(){
      if(mode==='stockfish'){
        askEngine();
      } else if(mode==='losing'){
        chooseWorst().then(mv=>{
          if(mv) game.move(mv);
          drawBoard();
        });
      }
    }

    // Stockfish
    function initEngine(){
      if(engine) engine.terminate();
      engine=new Worker('stockfish.js');
      engine.onmessage=e=>onEngineMsg(e.data);
      engine.postMessage('uci');
    }
    function askEngine(){
      const d=+document.getElementById('depthSelect').value;
      engine.postMessage('ucinewgame');
      engine.postMessage('position fen '+game.fen());
      engine.postMessage('go depth '+d);
    }
    function onEngineMsg(line){
      if(!line.startsWith('bestmove')) return;
      const mv=line.split(' ')[1];
      if(mv!=='(none)'){
        const from=mv.substr(0,2), to=mv.substr(2,2), pr=mv[4];
        game.move({from,to,promotion:pr||'q'});
        drawBoard();
      }
    }

    // Worst move
    function evaluateFen(fen,depth){
      return new Promise(r=>{
        const w=new Worker('stockfish.js');
        let score=null;
        w.onmessage=e=>{
          const l=e.data;
          if(l.includes('score cp')){
            const m=l.match(/score cp (-?\d+)/);
            if(m) score=+m[1];
          }
          if(l.startsWith('bestmove')){
            w.terminate(); r(score);
          }
        };
        w.postMessage('uci');
        setTimeout(()=>{
          w.postMessage('position fen '+fen);
          w.postMessage('go depth '+depth);
        },200);
      });
    }
    function chooseWorst(){
      const depth=+document.getElementById('depthSelect').value;
      const moves=game.moves({verbose:true});
      const ps=moves.map(m=>{
        const c=new Chess(game.fen()); c.move(m);
        return evaluateFen(c.fen(),depth).then(sc=>({m,sc}));
      });
      return Promise.all(ps).then(arr=>arr.reduce((a,b)=>b.sc>a.sc?b:a).m);
    }

    // Engine vs Engine
    let wf, bf;
    function startEngineVsEngine(){
      initEngineWhite(); initEngineBlack();
      runEngineVsEngine();
    }
    function initEngineWhite(){
      if(wf) wf.terminate();
      wf=new Worker('stockfish.js');
      wf.onmessage=e=>onEngineVsMsg(e.data,'w');
      wf.postMessage('uci');
    }
    function initEngineBlack(){
      if(bf) bf.terminate();
      bf=new Worker('stockfish.js');
      bf.onmessage=e=>onEngineVsMsg(e.data,'b');
      bf.postMessage('uci');
    }
    function runEngineVsEngine(){
      if(game.game_over()) return;
      const d=+document.getElementById('depthSelect').value;
      const turn=game.turn();
      const w=turn==='w'?wf:bf;
      w.postMessage('ucinewgame');
      w.postMessage('position fen '+game.fen());
      w.postMessage('go depth '+d);
    }
    function onEngineVsMsg(line,side){
      if(!line.startsWith('bestmove')||game.turn()!==side) return;
      const mv=line.split(' ')[1];
      if(mv!=='(none)'){
        game.move({from:mv.substr(0,2),to:mv.substr(2,2),promotion:mv[4]||'q'});
        drawBoard();
        setTimeout(runEngineVsEngine,200);
      }
    }

    // Setup / Analysis share piece palette
    let boardSetup={}, selectedPalettePiece='';
    function boardSetupMode(sq){
      boardSetup[sq]=selectedPalettePiece;
      drawSetup();
    }

    function initializeSetup(){
      boardSetup={};
      for(let r=1;r<=8;r++) for(let f of files) boardSetup[f+r]='';
      drawSetup();
    }
    function drawSetup(){
      for(let r=8;r>=1;r--){
        for(let f=0;f<8;f++){
          const sq=files[f]+r, td=document.getElementById(sq);
          const code=boardSetup[sq];
          td.textContent=code?unicode({type:code[1],color:code[0]}):'';
        }
      }
    }
    function makeFEN(turn){
      const parts=[];
      for(let r=8;r>=1;r--){
        let row='',e=0;
        for(let f=0;f<8;f++){
          const c=boardSetup[files[f]+r];
          if(!c) e++; else{ if(e){row+=e;e=0;} row+=c[1].toUpperCase()*0+ c[1];}
        }
        if(e) row+=e;
        parts.push(row);
      }
      return parts.join('/')+' '+turn+' - - 0 1';
    }

    // Analysis
    document.getElementById('stopAnalysis').onclick=stopAnalysis;
    document.getElementById('hideAnalysis').onclick=()=>{
      document.getElementById('analysis-panel').style.display='none';
      stopAnalysis();
    };
    document.getElementById('increaseLines').onclick=()=>{pvCount=Math.min(10,pvCount+1); document.getElementById('linesCount').textContent=pvCount; if(isAnalyzing) sendAnalysis();};
    document.getElementById('decreaseLines').onclick=()=>{pvCount=Math.max(1,pvCount-1); document.getElementById('linesCount').textContent=pvCount; if(isAnalyzing) sendAnalysis();};
    document.getElementById('depthSelect').onchange=()=>{if(isAnalyzing)sendAnalysis();};

    function startAnalysis(){
      initAnalysisEngine();
      isAnalyzing=true;
      document.getElementById('stopAnalysis').disabled=false;
      sendAnalysis();
    }
    function stopAnalysis(){
      isAnalyzing=false;
      document.getElementById('stopAnalysis').disabled=true;
      if(engine)engine.postMessage('stop');
    }
    function initAnalysisEngine(){
      if(engine)engine.terminate();
      engine=new Worker('stockfish.js');
      engine.onmessage=e=>onAnalysisMsg(e.data);
      engine.postMessage('uci');
    }
    function sendAnalysis(){
      engine.postMessage('ucinewgame');
      engine.postMessage('position fen '+game.fen());
      engine.postMessage('setoption name MultiPV value '+pvCount);
      engine.postMessage('setoption name UCI_AnalyseMode value true');
      engine.postMessage('go depth '+(+document.getElementById('depthSelect').value));
    }
    function onAnalysisMsg(line){
      if(!line.startsWith('info'))return;
      const t=line.split(' '), mp=t.indexOf('multipv'), sc=t.indexOf('score'), pv=t.indexOf('pv');
      if(mpp>-1&&sc>-1&&pv>-1&&t[sc+1]==='cp'){
        const num=+t[mp+1], cpval=+t[sc+2], moves=t.slice(pv+1);
        if(num===1) document.getElementById('numericEval').textContent=((cpval>=0?'+':'')+(cpval/100).toFixed(2));
        updatePV(num,cpval,moves);
      }
    }
    function updatePV(n,cp,m){
      const ul=document.getElementById('pv-list');
      let li=ul.querySelector(`li[data-pv="${n}"]`);
      if(!li){ li=document.createElement('li'); li.dataset.pv=n; li.onclick=()=>playPV(m); ul.appendChild(li); }
      li.textContent=`${n}. ${m.join(' ')} (${(cp/100).toFixed(2)})`;
    }
    function playPV(m){
      game.reset(); m.forEach(x=>game.move(x)); drawBoard();
    }

    // Import / Setup / Play
    document.getElementById('importFEN').onclick=()=>{
      const f=prompt('FEN:'); if(f&&game.load(f))drawBoard(); else alert('Bad FEN');
    };
    document.getElementById('importPGN').onclick=()=>{
      const p=prompt('PGN:'); try{game.load_pgn(p);drawBoard();}catch{alert('Bad PGN');}
    };
    document.getElementById('setupPosition').onclick=()=>{
      document.getElementById('modeSelect').value='setup';
      document.getElementById('modeSelect').dispatchEvent(new Event('change'));
    };
    document.getElementById('playPosition').onclick=()=>{
      customFEN=game.fen();
      document.getElementById('modeSelect').value='twoplayer';
      document.getElementById('modeSelect').dispatchEvent(new Event('change'));
    };

    // Reset
    function resetGame(){
      if(customFEN&&mode!=='setup') game.load(customFEN); else game.reset();
      drawBoard();
      if(mode==='enginevengine') setTimeout(startEngineVsEngine,200);
      if(mode==='setup') initializeSetup();
    }

    // Init
    window.onload=()=>{
      createBoard(); drawBoard(); updateStatus();
      document.getElementById('modeSelect').value='twoplayer';
    };
  </script>
</body>
</html>
