<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Mitch's Sigma Chess</title>
  <style>
    body { font-family: Arial, sans-serif; text-align: center; margin: 20px; }
    h1 { margin-bottom: 10px; }
    #game-options label,
    #game-options select,
    #game-options input { font-size: 16px; margin-right: 10px; }
    #chessboard { margin: 0 auto; display: inline-block; }
    table { border-collapse: collapse; }
    td {
      width: 60px;
      height: 60px;
      vertical-align: middle;
      text-align: center;
      font-size: 42px;
      cursor: pointer;
      user-select: none;
    }
    .dark { background-color: #b58863; }
    .light { background-color: #f0d9b5; }
    .selected { outline: 3px solid red; }
    #status { margin-top: 15px; font-size: 20px; }
    #resetButton, #startEngineVsEngine, #applyPositionButton { margin-top: 10px; padding: 5px 15px; font-size: 16px; }
    #version { font-size: 10px; text-align: center; margin-top: 10px; }
    /* Hide additional controls by default */
    #losing-depth, #engine-levels, #single-difficulty, #worst-depth-control, #setup-controls { display: none; }
  </style>
</head>
<body>
  <h1>Mitch's Sigma Chess</h1>

  <!-- Game Options -->
  <div id="game-options">
    <label for="modeSelect">Game Mode:</label>
    <select id="modeSelect">
      <option value="twoplayer">Two Player</option>
      <option value="stockfish">Play Against Stockfish</option>
      <option value="losing">Losing Mode (Stockfish tries to lose)</option>
      <option value="enginevengine">Engine vs Engine</option>
      <option value="setup">Setup Position</option>
    </select>

    <!-- Single Player Difficulty (for standard single-player) -->
    <span id="single-difficulty">
      <label for="difficultySelect">Difficulty:</label>
      <select id="difficultySelect">
        <option value="-1">-1</option>
        <option value="0">0 (Weakest)</option>
        <option value="1">1</option>
        <option value="2">2</option>
        <option value="3">3</option>
        <option value="4">4</option>
        <option value="5" selected>5 (Medium)</option>
        <option value="6">6</option>
        <option value="7">7</option>
        <option value="8">8</option>
        <option value="9">9</option>
        <option value="10">10 (Strong)</option>
        <option value="11">11</option>
        <option value="12">12</option>
        <option value="13">13</option>
        <option value="14">14</option>
        <option value="15">15</option>
        <option value="16">16</option>
        <option value="17">17</option>
        <option value="18">18</option>
        <option value="19">19</option>
        <option value="20">20 (Strongest)</option>
      </select>
    </span>

    <!-- Losing Mode Depth Selector -->
    <span id="losing-depth">
      <label for="losingDepthSelect">Losing Depth:</label>
      <select id="losingDepthSelect">
         <option value="1">1</option>
         <option value="2">2</option>
         <option value="3">3</option>
         <option value="4">4</option>
         <option value="5">5</option>
         <option value="6">6</option>
         <option value="7">7</option>
         <option value="8">8</option>
         <option value="9">9</option>
         <option value="10" selected>10</option>
         <option value="11">11</option>
         <option value="12">12</option>
         <option value="13">13</option>
         <option value="14">14</option>
         <option value="15">15</option>
         <option value="16">16</option>
         <option value="17">17</option>
         <option value="18">18</option>
         <option value="19">19</option>
         <option value="20">20</option>
      </select>
    </span>

    <!-- Engine vs Engine Difficulty selectors -->
    <span id="engine-levels">
      <label for="whiteDifficultySelect">White Skill:</label>
      <select id="whiteDifficultySelect">
        <option value="-1">-1</option>
        <option value="0">0</option>
        <option value="1">1</option>
        <option value="2">2</option>
        <option value="3">3</option>
        <option value="4">4</option>
        <option value="5" selected>5</option>
        <option value="6">6</option>
        <option value="7">7</option>
        <option value="8">8</option>
        <option value="9">9</option>
        <option value="10">10</option>
        <option value="11">11</option>
        <option value="12">12</option>
        <option value="13">13</option>
        <option value="14">14</option>
        <option value="15">15</option>
        <option value="16">16</option>
        <option value="17">17</option>
        <option value="18">18</option>
        <option value="19">19</option>
        <option value="20">20</option>
      </select>

      <label for="blackDifficultySelect">Black Skill:</label>
      <select id="blackDifficultySelect">
        <option value="-1">-1</option>
        <option value="0">0</option>
        <option value="1">1</option>
        <option value="2">2</option>
        <option value="3">3</option>
        <option value="4">4</option>
        <option value="5" selected>5</option>
        <option value="6">6</option>
        <option value="7">7</option>
        <option value="8">8</option>
        <option value="9">9</option>
        <option value="10">10</option>
        <option value="11">11</option>
        <option value="12">12</option>
        <option value="13">13</option>
        <option value="14">14</option>
        <option value="15">15</option>
        <option value="16">16</option>
        <option value="17">17</option>
        <option value="18">18</option>
        <option value="19">19</option>
        <option value="20">20</option>
      </select>
    </span>

    <!-- Worst Move Depth for -1 difficulties -->
    <span id="worst-depth-control">
      <label for="worstDepthInput">Worst Move Depth (for -1):</label>
      <input type="number" id="worstDepthInput" min="1" max="20" value="10" />
    </span>

    <!-- Setup Position Controls -->
    <span id="setup-controls">
      <label for="fenInput">FEN:</label>
      <input type="text" id="fenInput" size="50" value="rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1" />
      <label for="turnSelect">Turn:</label>
      <select id="turnSelect">
        <option value="w" selected>White to move</option>
        <option value="b">Black to move</option>
      </select>
      <button id="applyPositionButton">Apply Position</button>
    </span>
  </div>

  <!-- Engine vs Engine Start Button (only visible in Engine vs Engine mode) -->
  <button id="startEngineVsEngine">Start Engine vs Engine</button>

  <!-- Chessboard and Status -->
  <div id="chessboard"></div>
  <div id="status"></div>
  <button id="resetButton">Reset Game</button>

  <!-- Version Number -->
  <div id="version">v.1.8</div>

  <!-- Include chess.js via CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
  <script>
    // Global Variables
    var game = new Chess();
    var selectedSquare = null;
    var boardDiv = document.getElementById("chessboard");
    var isSinglePlayerMode = false; // true when a human plays against the engine
    var currentMode = "twoplayer";  // Modes: 'twoplayer', 'stockfish', 'losing', 'enginevengine', 'setup'
    var humanColor = 'w';           // In single-player modes, human plays white
    var files = ['a','b','c','d','e','f','g','h'];

    // Stockfish Workers for single-player and engine-vs-engine modes
    var stockfish = null;      // For standard single-player mode
    var stockfishWhite = null; // For engine-vs-engine, white engine
    var stockfishBlack = null; // For engine-vs-engine, black engine

    /* ----------------------- Board Rendering ----------------------- */
    function createBoard() {
      var table = document.createElement("table");
      for (var i = 0; i < 8; i++) {
        var row = document.createElement("tr");
        var rank = 8 - i;
        for (var j = 0; j < 8; j++) {
          var cell = document.createElement("td");
          var file = files[j];
          var square = file + rank;
          cell.id = square;
          cell.className = ((i + j) % 2 === 0) ? "dark" : "light";
          cell.addEventListener("click", onCellClick);
          row.appendChild(cell);
        }
        table.appendChild(row);
      }
      boardDiv.innerHTML = "";
      boardDiv.appendChild(table);
    }

    function drawBoard() {
      var boardState = game.board();
      for (var i = 0; i < 8; i++) {
        var rank = 8 - i;
        for (var j = 0; j < 8; j++) {
          var cell = document.getElementById(files[j] + rank);
          var piece = boardState[i][j];
          cell.innerHTML = piece ? getUnicode(piece) : "";
          cell.classList.remove("selected");
        }
      }
      updateStatus();
    }

    // Map chess pieces to Unicode symbols.
    function getUnicode(piece) {
      var unicode = {
        'p': {'w': '♙', 'b': '♟'},
        'r': {'w': '♖', 'b': '♜'},
        'n': {'w': '♘', 'b': '♞'},
        'b': {'w': '♗', 'b': '♝'},
        'q': {'w': '♕', 'b': '♛'},
        'k': {'w': '♔', 'b': '♚'}
      };
      return unicode[piece.type][piece.color];
    }

    function updateStatus() {
      var statusDiv = document.getElementById("status");
      var status = "";
      if (game.in_checkmate()) {
        status = "Game over: " + (game.turn() === 'w' ? "Black" : "White") + " wins by checkmate.";
      } else if (game.in_draw()) {
        status = "Game over: drawn position.";
      } else {
        status = (game.turn() === 'w' ? "White" : "Black") + " to move.";
        if (game.in_check()) status += " Check!";
      }
      statusDiv.textContent = status;
    }

    /* ----------------------- Helper Functions for Promotion ----------------------- */
    // For engine moves: try alternative promotion choices if the move results in draw.
    function getEnginePromotionMove(fen, from, to) {
      var promotions = ['q', 'r', 'b', 'n'];
      for (var i = 0; i < promotions.length; i++) {
        var promo = promotions[i];
        var clone = new Chess(fen);
        var move = clone.move({ from: from, to: to, promotion: promo });
        if (move && !clone.in_draw()) {
          return { from: from, to: to, promotion: promo };
        }
      }
      return { from: from, to: to, promotion: 'q' };
    }

    // Adjust engine move promotions if necessary.
    function fixEnginePromotion(bestMove, currentFen) {
      var from = bestMove.substring(0, 2);
      var to = bestMove.substring(2, 4);
      if (bestMove.length === 5) {
        var promo = bestMove[4];
        var clone = new Chess(currentFen);
        clone.move({ from: from, to: to, promotion: promo });
        if (clone.in_draw()) {
          return getEnginePromotionMove(currentFen, from, to);
        } else {
          return { from: from, to: to, promotion: promo };
        }
      }
      return { from: from, to: to };
    }

    /* ----------------------- Move Handling (with Underpromotion) ----------------------- */
    function onCellClick(e) {
      if (currentMode === "enginevengine") return;
      var square = e.currentTarget.id;
      if (!selectedSquare) {
        var piece = game.get(square);
        if (piece && piece.color === game.turn()) {
          if ((currentMode === "stockfish" || currentMode === "losing") && piece.color !== humanColor) return;
          selectedSquare = square;
          e.currentTarget.classList.add("selected");
        }
      } else {
        if (selectedSquare === square) {
          e.currentTarget.classList.remove("selected");
          selectedSquare = null;
          return;
        }
        var from = selectedSquare, to = square;
        var piece = game.get(from);
        var promoChoice = 'q';
        if (piece && piece.type === 'p' &&
            ((piece.color === 'w' && square.endsWith("8")) ||
             (piece.color === 'b' && square.endsWith("1")))) {
          var choice = prompt("Promote to (q, r, b, n):", "q");
          if (choice && ["q", "r", "b", "n"].includes(choice.toLowerCase())) {
            promoChoice = choice.toLowerCase();
          }
        }
        var move = game.move({ from: from, to: to, promotion: promoChoice });
        if (move === null) { alert("Invalid move!"); }
        selectedSquare = null;
        drawBoard();

        // After a human move in modes that involve engine response:
        if ((currentMode === "stockfish" || currentMode === "losing") &&
            game.turn() !== humanColor && !game.game_over()) {
          if (currentMode === "stockfish") {
            var diff = parseInt(document.getElementById("difficultySelect").value, 10);
            if (diff === -1) {
              var worstDepth = parseInt(document.getElementById("worstDepthInput").value, 10) || 10;
              setTimeout(function() {
                chooseWorstMoveUsingStockfish(worstDepth).then(function(engineMove) {
                  if (engineMove) { game.move(engineMove); }
                  drawBoard();
                });
              }, 250);
            } else {
              setTimeout(function() { askEngineForMove(game.fen()); }, 250);
            }
          } else if (currentMode === "losing") {
            setTimeout(function() {
              chooseWorstMoveUsingStockfish().then(function(engineMove) {
                if (engineMove) { game.move(engineMove); }
                drawBoard();
              });
            }, 250);
          }
        }
      }
    }

    /* ----------------------- Stockfish Integration (Standard Mode) ----------------------- */
    function initStockfish() {
      if (typeof(Worker) === "undefined") { console.error("Your browser does not support Web Workers."); return; }
      if (!stockfish) {
        stockfish = new Worker('stockfish.js');
        stockfish.onmessage = function(e) {
          var msg = e.data;
          console.log("Stockfish:", msg);
          if (msg.indexOf("bestmove") === 0) {
            var tokens = msg.split(" ");
            var bestMove = tokens[1];
            if (bestMove && bestMove !== "(none)") {
              var moveObj = fixEnginePromotion(bestMove, game.fen());
              game.move(moveObj);
              drawBoard();
            }
          }
        };
        stockfish.postMessage("uci");
        setTimeout(updateSingleEngineDifficulty, 500);
      } else {
        updateSingleEngineDifficulty();
      }
    }

    function updateSingleEngineDifficulty() {
      var diffSelect = document.getElementById("difficultySelect");
      var diff = diffSelect.value;
      stockfish.postMessage("setoption name Skill Level value " + diff);
    }

    function askEngineForMove(fen) {
      if (!stockfish) { console.error("Stockfish engine not initialized."); return; }
      stockfish.postMessage("position fen " + fen);
      stockfish.postMessage("go movetime 500");
    }

    /* ----------------------- Losing Mode Using Stockfish ----------------------- */
    function evaluateMoveWithStockfish(fen, depth = 12) {
      return new Promise(function(resolve, reject) {
        var worker = new Worker('stockfish.js');
        var evaluationScore = null;
        worker.onmessage = function(e) {
          var line = e.data;
          if (line.indexOf("info") !== -1 && line.indexOf("score cp") !== -1) {
            var scoreMatch = line.match(/score cp (-?\d+)/);
            if (scoreMatch) { evaluationScore = parseInt(scoreMatch[1], 10); }
          }
          if (line.indexOf("bestmove") === 0) {
            worker.terminate();
            resolve(evaluationScore);
          }
        };
        worker.postMessage("uci");
        setTimeout(function() {
          worker.postMessage("position fen " + fen);
          worker.postMessage("go depth " + depth);
        }, 200);
      });
    }

    // Accept optional custom depth parameter.
    function chooseWorstMoveUsingStockfish(customDepth) {
      var moves = game.moves({ verbose: true });
      if (moves.length === 0) return Promise.resolve(null);
      var depth = (typeof customDepth !== 'undefined')
                  ? customDepth
                  : parseInt(document.getElementById("losingDepthSelect").value, 10);
      var evaluations = moves.map(function(move) {
         var clone = new Chess(game.fen());
         clone.move(move);
         return evaluateMoveWithStockfish(clone.fen(), depth).then(function(evalScore) {
              return { move: move, evalScore: evalScore };
         });
      });
      return Promise.all(evaluations).then(function(results) {
         var worstMoveObject = results.reduce(function(acc, cur) {
            return (cur.evalScore > acc.evalScore) ? cur : acc;
         }, results[0]);
         return worstMoveObject.move;
      });
    }

    /* ----------------------- Engine vs Engine Mode ----------------------- */
    function initEngineVsEngine() {
      if (stockfish) { stockfish.terminate(); stockfish = null; }
      if (typeof(Worker) === "undefined") { console.error("Your browser does not support Web Workers."); return; }
      // Initialize Stockfish for White.
      if (!stockfishWhite) {
        stockfishWhite = new Worker('stockfish.js');
        stockfishWhite.onmessage = function(e) {
          var msg = e.data;
          if (msg.indexOf("bestmove") === 0 && game.turn() === 'w') {
            var tokens = msg.split(" ");
            var bestMove = tokens[1];
            if (bestMove && bestMove !== "(none)") {
              var moveObj = fixEnginePromotion(bestMove, game.fen());
              game.move(moveObj);
              drawBoard();
              setTimeout(autoPlayEngineVsEngine, 250);
            }
          }
        };
        stockfishWhite.postMessage("uci");
        setTimeout(function(){ updateEngineDifficulty('w'); },500);
      } else { updateEngineDifficulty('w'); }

      // Initialize Stockfish for Black.
      if (!stockfishBlack) {
        stockfishBlack = new Worker('stockfish.js');
        stockfishBlack.onmessage = function(e) {
          var msg = e.data;
          if (msg.indexOf("bestmove") === 0 && game.turn() === 'b') {
            var tokens = msg.split(" ");
            var bestMove = tokens[1];
            if (bestMove && bestMove !== "(none)") {
              var moveObj = fixEnginePromotion(bestMove, game.fen());
              game.move(moveObj);
              drawBoard();
              setTimeout(autoPlayEngineVsEngine, 250);
            }
          }
        };
        stockfishBlack.postMessage("uci");
        setTimeout(function(){ updateEngineDifficulty('b'); },500);
      } else { updateEngineDifficulty('b'); }
      autoPlayEngineVsEngine();
    }

    function updateEngineDifficulty(side) {
      if (side === 'w') {
        var level = document.getElementById("whiteDifficultySelect").value;
        stockfishWhite.postMessage("setoption name Skill Level value " + level);
      } else if (side === 'b') {
        var level = document.getElementById("blackDifficultySelect").value;
        stockfishBlack.postMessage("setoption name Skill Level value " + level);
      }
    }

    function autoPlayEngineVsEngine() {
      if (game.game_over()) { updateStatus(); return; }
      var fen = game.fen();
      if (game.turn() === 'w') {
        var whiteDiff = parseInt(document.getElementById("whiteDifficultySelect").value, 10);
        if (whiteDiff === -1) {
          var worstDepth = parseInt(document.getElementById("worstDepthInput").value, 10) || 10;
          chooseWorstMoveUsingStockfish(worstDepth).then(function(engineMove) {
            if (engineMove) { game.move(engineMove); }
            drawBoard();
            setTimeout(autoPlayEngineVsEngine, 250);
          });
        } else {
          stockfishWhite.postMessage("position fen " + fen);
          stockfishWhite.postMessage("go movetime 500");
        }
      } else if (game.turn() === 'b') {
        var blackDiff = parseInt(document.getElementById("blackDifficultySelect").value, 10);
        if (blackDiff === -1) {
          var worstDepth = parseInt(document.getElementById("worstDepthInput").value, 10) || 10;
          chooseWorstMoveUsingStockfish(worstDepth).then(function(engineMove) {
            if (engineMove) { game.move(engineMove); }
            drawBoard();
            setTimeout(autoPlayEngineVsEngine, 250);
          });
        } else {
          stockfishBlack.postMessage("position fen " + fen);
          stockfishBlack.postMessage("go movetime 500");
        }
      }
    }

    /* ----------------------- Custom Setup Mode ----------------------- */
    function applyCustomPosition() {
      var fenInput = document.getElementById("fenInput").value.trim();
      var turnSelect = document.getElementById("turnSelect").value;
      if (!fenInput) { alert("Please enter a valid FEN."); return; }
      // Adjust the FEN's turn field: FEN has six fields separated by spaces.
      var parts = fenInput.split(" ");
      if (parts.length < 6) {
        alert("FEN must have 6 fields.");
        return;
      }
      parts[1] = turnSelect;  // Override turn with user's choice.
      var adjustedFen = parts.join(" ");
      var loaded = game.load(adjustedFen);
      if (!loaded) {
        alert("Invalid FEN provided.");
      }
      drawBoard();
    }

    /* ----------------------- UI Mode Handling & Game Reset ----------------------- */
    function updateUI() {
      var mode = document.getElementById("modeSelect").value;
      currentMode = mode;
      // Show/hide controls based on mode.
      document.getElementById("single-difficulty").style.display = (mode === "stockfish") ? "inline" : "none";
      document.getElementById("losing-depth").style.display = (mode === "losing") ? "inline" : "none";
      document.getElementById("engine-levels").style.display = (mode === "enginevengine") ? "inline" : "none";
      document.getElementById("setup-controls").style.display = (mode === "setup") ? "inline" : "none";
      document.getElementById("startEngineVsEngine").style.display = (mode === "enginevengine") ? "inline-block" : "none";
      updateWorstDepthControlVisibility();
    }

    function updateWorstDepthControlVisibility() {
      var mode = currentMode;
      var show = false;
      if (mode === "stockfish") {
        if (document.getElementById("difficultySelect").value === "-1") show = true;
      } else if (mode === "enginevengine") {
        if (document.getElementById("whiteDifficultySelect").value === "-1" ||
            document.getElementById("blackDifficultySelect").value === "-1") {
          show = true;
        }
      }
      document.getElementById("worst-depth-control").style.display = show ? "inline" : "none";
    }

    document.getElementById("modeSelect").addEventListener("change", function() {
      updateUI();
      resetGame();
    });
    document.getElementById("difficultySelect").addEventListener("change", updateWorstDepthControlVisibility);
    document.getElementById("whiteDifficultySelect").addEventListener("change", updateWorstDepthControlVisibility);
    document.getElementById("blackDifficultySelect").addEventListener("change", updateWorstDepthControlVisibility);
    document.getElementById("applyPositionButton").addEventListener("click", applyCustomPosition);
    document.getElementById("startEngineVsEngine").addEventListener("click", function() {
      initEngineVsEngine();
    });

    function resetGame() {
      game.reset();
      selectedSquare = null;
      drawBoard();
      if (currentMode !== "setup" && currentMode === "enginevengine") {
        setTimeout(autoPlayEngineVsEngine, 250);
      }
    }

    document.getElementById("resetButton").addEventListener("click", resetGame);

    // Initialize board and UI on load.
    createBoard();
    drawBoard();
    updateUI();
  </script>
</body>
</html>
