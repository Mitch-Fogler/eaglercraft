<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Over the Board Chess</title>
  <style>
    body { font-family: Arial, sans-serif; text-align: center; margin: 20px; }
    h1 { margin-bottom: 10px; }
    #game-options label,
    #game-options select { font-size: 16px; margin-right: 10px; }
    #chessboard { margin: 0 auto; display: inline-block; }
    table { border-collapse: collapse; }
    td { width: 60px; height: 60px; vertical-align: middle; text-align: center; font-size: 42px; cursor: pointer; user-select: none; }
    .dark { background-color: #b58863; }
    .light { background-color: #f0d9b5; }
    .selected { outline: 3px solid red; }
    #status { margin-top: 15px; font-size: 20px; }
    #resetButton { margin-top: 10px; padding: 5px 15px; font-size: 16px; }
  </style>
</head>
<body>
  <h1>Over the Board Chess</h1>

  <!-- Game Options -->
  <div id="game-options">
    <label for="modeSelect">Game Mode:</label>
    <select id="modeSelect">
      <option value="twoplayer">Two Player</option>
      <option value="stockfish">Play Against Stockfish</option>
      <option value="losing">Losing Mode (Stockfish tries to lose)</option>
      <option value="enginevengine">Engine vs Engine</option>
    </select>

    <!-- Single Engine Difficulty (for standard single-player) -->
    <span id="single-difficulty" style="display:none;">
      <label for="difficultySelect">Difficulty:</label>
      <select id="difficultySelect">
        <!-- Stockfish Skill Level: 0 (weakest) to 20 (strongest) -->
        <option value="0">0 (Weakest)</option>
        <option value="1">1</option>
        <option value="2">2</option>
        <option value="3">3</option>
        <option value="4">4</option>
        <option value="5" selected>5 (Medium)</option>
        <option value="6">6</option>
        <option value="7">7</option>
        <option value="8">8</option>
        <option value="9">9</option>
        <option value="10">10 (Strong)</option>
        <option value="11">11</option>
        <option value="12">12</option>
        <option value="13">13</option>
        <option value="14">14</option>
        <option value="15">15</option>
        <option value="16">16</option>
        <option value="17">17</option>
        <option value="18">18</option>
        <option value="19">19</option>
        <option value="20">20 (Strongest)</option>
      </select>
    </span>

    <!-- Engine vs Engine Difficulty selectors -->
    <span id="engine-levels" style="display:none;">
      <label for="whiteDifficultySelect">White Skill:</label>
      <select id="whiteDifficultySelect">
        <option value="0">0</option>
        <option value="1">1</option>
        <option value="2">2</option>
        <option value="3">3</option>
        <option value="4">4</option>
        <option value="5" selected>5</option>
        <option value="6">6</option>
        <option value="7">7</option>
        <option value="8">8</option>
        <option value="9">9</option>
        <option value="10">10</option>
        <option value="11">11</option>
        <option value="12">12</option>
        <option value="13">13</option>
        <option value="14">14</option>
        <option value="15">15</option>
        <option value="16">16</option>
        <option value="17">17</option>
        <option value="18">18</option>
        <option value="19">19</option>
        <option value="20">20</option>
      </select>

      <label for="blackDifficultySelect">Black Skill:</label>
      <select id="blackDifficultySelect">
        <option value="0">0</option>
        <option value="1">1</option>
        <option value="2">2</option>
        <option value="3">3</option>
        <option value="4">4</option>
        <option value="5" selected>5</option>
        <option value="6">6</option>
        <option value="7">7</option>
        <option value="8">8</option>
        <option value="9">9</option>
        <option value="10">10</option>
        <option value="11">11</option>
        <option value="12">12</option>
        <option value="13">13</option>
        <option value="14">14</option>
        <option value="15">15</option>
        <option value="16">16</option>
        <option value="17">17</option>
        <option value="18">18</option>
        <option value="19">19</option>
        <option value="20">20</option>
      </select>
    </span>
  </div>

  <!-- Chessboard and Status -->
  <div id="chessboard"></div>
  <div id="status"></div>
  <button id="resetButton">Reset Game</button>

  <!-- Include chess.js via CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
  
  <script>
    // Global Variables
    var game = new Chess();
    var selectedSquare = null;
    var boardDiv = document.getElementById("chessboard");
    var isSinglePlayerMode = false; // For modes where a human plays vs an engine.
    var currentMode = "twoplayer"; // Options: 'twoplayer', 'stockfish', 'losing', 'enginevengine'
    var humanColor = 'w'; // In single‑player modes, human is white by default.
    var files = ['a','b','c','d','e','f','g','h'];
    
    // Stockfish Workers for Standard and Engine vs Engine modes
    var stockfish = null;          // Used for standard single‑player mode.
    var stockfishWhite = null;     // Used for engine vs engine mode (white side)
    var stockfishBlack = null;     // Used for engine vs engine mode (black side)

    /* ----------------------- Board Rendering ----------------------- */
    function createBoard() {
      var table = document.createElement("table");
      for (var i = 0; i < 8; i++) {
        var row = document.createElement("tr");
        var rank = 8 - i;
        for (var j = 0; j < 8; j++) {
          var cell = document.createElement("td");
          var file = files[j];
          var square = file + rank;
          cell.id = square;
          cell.className = ((i + j) % 2 === 0) ? "dark" : "light";
          cell.addEventListener("click", onCellClick);
          row.appendChild(cell);
        }
        table.appendChild(row);
      }
      boardDiv.innerHTML = "";
      boardDiv.appendChild(table);
    }
    
    function drawBoard() {
      var boardState = game.board();
      for (var i = 0; i < 8; i++) {
        var rank = 8 - i;
        for (var j = 0; j < 8; j++) {
          var cell = document.getElementById(files[j] + rank);
          var piece = boardState[i][j];
          cell.innerHTML = piece ? getUnicode(piece) : "";
          cell.classList.remove("selected");
        }
      }
      updateStatus();
    }
    
    // Map chess pieces to Unicode symbols.
    function getUnicode(piece) {
      var unicode = {
        'p': {'w': '♙', 'b': '♟'},
        'r': {'w': '♖', 'b': '♜'},
        'n': {'w': '♘', 'b': '♞'},
        'b': {'w': '♗', 'b': '♝'},
        'q': {'w': '♕', 'b': '♛'},
        'k': {'w': '♔', 'b': '♚'}
      };
      return unicode[piece.type][piece.color];
    }
    
    function updateStatus() {
      var statusDiv = document.getElementById("status");
      var status = "";
      if (game.in_checkmate()) {
        status = "Game over: " + (game.turn() === 'w' ? "Black" : "White") + " wins by checkmate.";
      } else if (game.in_draw()) {
        status = "Game over: drawn position.";
      } else {
        status = (game.turn() === 'w' ? "White" : "Black") + " to move.";
        if (game.in_check()) status += " Check!";
      }
      statusDiv.textContent = status;
    }

    /* ----------------------- Move Handling ----------------------- */
    function onCellClick(e) {
      // In engine vs engine mode, disable human moves.
      if (currentMode === "enginevengine") return;
      var square = e.currentTarget.id;
      if (!selectedSquare) {
        var piece = game.get(square);
        if (piece && piece.color === game.turn()) {
          // In single‑player modes, only allow the human to move their own pieces.
          if ((currentMode === "stockfish" || currentMode === "losing") && piece.color !== humanColor) return;
          selectedSquare = square;
          e.currentTarget.classList.add("selected");
        }
      } else {
        if (selectedSquare === square) {
          e.currentTarget.classList.remove("selected");
          selectedSquare = null;
          return;
        }
        var move = game.move({ from: selectedSquare, to: square, promotion: 'q' });
        if (move === null) {
          alert("Invalid move!");
        }
        selectedSquare = null;
        drawBoard();
        // After a human move, if in a single‑player mode, let the engine move.
        if ((currentMode === "stockfish" || currentMode === "losing") && game.turn() !== humanColor && !game.game_over()) {
          if (currentMode === "stockfish") {
            setTimeout(function() { askEngineForMove(game.fen()); }, 250);
          } else if (currentMode === "losing") {
            // Use Stockfish at full strength to find the worst move.
            setTimeout(function() {
              chooseWorstMoveUsingStockfish().then(function(engineMove) {
                if (engineMove) {
                  game.move({ from: engineMove.from, to: engineMove.to, promotion: 'q' });
                }
                drawBoard();
              });
            }, 250);
          }
        }
      }
    }
    
    /* ----------------------- Stockfish Integration (Standard Mode) ----------------------- */
    function initStockfish() {
      if (typeof(Worker) === "undefined") {
        console.error("Your browser does not support Web Workers.");
        return;
      }
      if (!stockfish) {
        stockfish = new Worker('stockfish.js');
        stockfish.onmessage = function(e) {
          var msg = e.data;
          console.log("Stockfish:", msg);
          if (msg.indexOf("bestmove") === 0) {
            var tokens = msg.split(" ");
            var bestMove = tokens[1];
            if (bestMove && bestMove !== "(none)") {
              game.move({
                from: bestMove.substring(0, 2),
                to: bestMove.substring(2, 4),
                promotion: 'q'
              });
              drawBoard();
            }
          }
        };
        stockfish.postMessage("uci");
        setTimeout(updateSingleEngineDifficulty, 500);
      } else {
        updateSingleEngineDifficulty();
      }
    }
    
    function updateSingleEngineDifficulty() {
      var diffSelect = document.getElementById("difficultySelect");
      var diff = diffSelect.value;
      stockfish.postMessage("setoption name Skill Level value " + diff);
    }
    
    function askEngineForMove(fen) {
      if (!stockfish) {
        console.error("Stockfish engine not initialized.");
        return;
      }
      stockfish.postMessage("position fen " + fen);
      stockfish.postMessage("go movetime 500");
    }
    
    /* ----------------------- Losing Mode Using Stockfish ----------------------- */
    // This function creates a new temporary Stockfish worker to evaluate a position.
    // It sends the provided FEN to Stockfish, asks it to search to a given depth,
    // and parses the evaluation (in centipawns) from the info lines.
    function evaluateMoveWithStockfish(fen, depth = 12) {
      return new Promise(function(resolve, reject) {
        var worker = new Worker('stockfish.js');
        var evaluationScore = null;
        worker.onmessage = function(e) {
          var line = e.data;
          // Look for info lines containing "score cp"
          if (line.indexOf("info") !== -1 && line.indexOf("score cp") !== -1) {
            var scoreMatch = line.match(/score cp (-?\d+)/);
            if (scoreMatch) {
              evaluationScore = parseInt(scoreMatch[1], 10);
            }
          }
          // When bestmove is received, resolve with the last score seen.
          if (line.indexOf("bestmove") === 0) {
            worker.terminate();
            resolve(evaluationScore);
          }
        };
        worker.postMessage("uci");
        setTimeout(function() {
          worker.postMessage("position fen " + fen);
          worker.postMessage("go depth " + depth);
        }, 200);
      });
    }
    
    // This function uses Stockfish to evaluate every legal move and then chooses the move that gives
    // the worst outcome for the engine (i.e. highest evaluation for White when engine is Black).
    function chooseWorstMoveUsingStockfish() {
      var moves = game.moves({ verbose: true });
      if (moves.length === 0) return Promise.resolve(null);
      // Evaluate each move concurrently.
      var evaluations = moves.map(function(move) {
        var clone = new Chess(game.fen());
        clone.move(move);
        return evaluateMoveWithStockfish(clone.fen(), 12).then(function(evalScore) {
          return { move: move, evalScore: evalScore };
        });
      });
      return Promise.all(evaluations).then(function(results) {
        // In our scenario, human is white so engine is black.  A higher score (more positive for white)
        // means a worse move for Black.
        var worstMoveObject = results.reduce(function(acc, cur) {
          return (cur.evalScore > acc.evalScore) ? cur : acc;
        }, results[0]);
        return worstMoveObject.move;
      });
    }
    
    /* ----------------------- Engine vs Engine Mode ----------------------- */
    var stockfishWhite = null;
    var stockfishBlack = null;
    
    function initEngineVsEngine() {
      if (stockfish) {
        stockfish.terminate();
        stockfish = null;
      }
      if (typeof(Worker) === "undefined") {
        console.error("Your browser does not support Web Workers.");
        return;
      }
      // Initialize Stockfish for White.
      if (!stockfishWhite) {
        stockfishWhite = new Worker('stockfish.js');
        stockfishWhite.onmessage = function(e) {
          var msg = e.data;
          if (msg.indexOf("bestmove") === 0 && game.turn() === 'w') {
            var tokens = msg.split(" ");
            var bestMove = tokens[1];
            if (bestMove && bestMove !== "(none)") {
              game.move({
                from: bestMove.substring(0,2),
                to: bestMove.substring(2,4),
                promotion: 'q'
              });
              drawBoard();
              setTimeout(autoPlayEngineVsEngine, 250);
            }
          }
        };
        stockfishWhite.postMessage("uci");
        setTimeout(function(){ updateEngineDifficulty('w'); },500);
      } else {
        updateEngineDifficulty('w');
      }
      
      // Initialize Stockfish for Black.
      if (!stockfishBlack) {
        stockfishBlack = new Worker('stockfish.js');
        stockfishBlack.onmessage = function(e) {
          var msg = e.data;
          if (msg.indexOf("bestmove") === 0 && game.turn() === 'b') {
            var tokens = msg.split(" ");
            var bestMove = tokens[1];
            if (bestMove && bestMove !== "(none)") {
              game.move({
                from: bestMove.substring(0,2),
                to: bestMove.substring(2,4),
                promotion: 'q'
              });
              drawBoard();
              setTimeout(autoPlayEngineVsEngine, 250);
            }
          }
        };
        stockfishBlack.postMessage("uci");
        setTimeout(function(){ updateEngineDifficulty('b'); },500);
      } else {
        updateEngineDifficulty('b');
      }
      autoPlayEngineVsEngine();
    }
    
    function updateEngineDifficulty(side) {
      if (side === 'w') {
        var level = document.getElementById("whiteDifficultySelect").value;
        stockfishWhite.postMessage("setoption name Skill Level value " + level);
      } else if (side === 'b') {
        var level = document.getElementById("blackDifficultySelect").value;
        stockfishBlack.postMessage("setoption name Skill Level value " + level);
      }
    }
    
    function autoPlayEngineVsEngine() {
      if (game.game_over()) {
        updateStatus();
        return;
      }
      var fen = game.fen();
      if (game.turn() === 'w') {
        stockfishWhite.postMessage("position fen " + fen);
        stockfishWhite.postMessage("go movetime 500");
      } else if (game.turn() === 'b') {
        stockfishBlack.postMessage("position fen " + fen);
        stockfishBlack.postMessage("go movetime 500");
      }
    }
    
    /* ----------------------- UI Mode Handling & Game Reset ----------------------- */
    document.getElementById("modeSelect").addEventListener("change", function(e) {
      currentMode = e.target.value;
      if (currentMode === "stockfish") {
        isSinglePlayerMode = true;
        humanColor = 'w';
        document.getElementById("single-difficulty").style.display = "inline";
        document.getElementById("engine-levels").style.display = "none";
        initStockfish();
      } else if (currentMode === "losing") {
        isSinglePlayerMode = true;
        humanColor = 'w';
        document.getElementById("single-difficulty").style.display = "none";
        document.getElementById("engine-levels").style.display = "none";
      } else if (currentMode === "enginevengine") {
        isSinglePlayerMode = false;
        document.getElementById("single-difficulty").style.display = "none";
        document.getElementById("engine-levels").style.display = "inline";
        initEngineVsEngine();
      } else { // Two Player Mode
        isSinglePlayerMode = false;
        humanColor = null;
        document.getElementById("single-difficulty").style.display = "none";
        document.getElementById("engine-levels").style.display = "none";
      }
      resetGame();
    });
    
    document.getElementById("whiteDifficultySelect").addEventListener("change", function(){
      if (currentMode === "enginevengine" && stockfishWhite) { updateEngineDifficulty('w'); }
    });
    document.getElementById("blackDifficultySelect").addEventListener("change", function(){
      if (currentMode === "enginevengine" && stockfishBlack) { updateEngineDifficulty('b'); }
    });
    
    function resetGame() {
      game.reset();
      selectedSquare = null;
      drawBoard();
      if (currentMode === "enginevengine") {
        setTimeout(autoPlayEngineVsEngine, 250);
      }
    }
    
    document.getElementById("resetButton").addEventListener("click", resetGame);
    
    createBoard();
    drawBoard();
  </script>
</body>
</html>
