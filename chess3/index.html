<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Mitch's Sigma Chess</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    h1 { text-align: center; margin-bottom: 10px; }
    #game-options { text-align: center; margin-bottom: 10px; }
    #status { text-align: center; margin-top: 15px; font-size: 20px; }
    #version { text-align: center; font-size: 10px; margin-top: 10px; }

    /* Flex container: board + analysis panel */
    #board-container { display: flex; justify-content: center; align-items: flex-start; }
    #analysis-panel {
      width: 260px; margin-left: 10px; font-size: 14px; line-height: 1.3;
      display: none;
    }
    #analysis-panel button,
    #analysis-panel select,
    #analysis-panel input { margin: 4px 0; font-size: 14px; }

    /* Chessboard table */
    #chessboard { margin: 0; }
    table { border-collapse: collapse; }
    td {
      width: 60px; height: 60px;
      text-align: center; vertical-align: middle;
      font-size: 42px; cursor: pointer; user-select: none;
    }
    .light { background: #f0d9b5; }
    .dark  { background: #b58863; }
    .selected { outline: 3px solid red; }

    /* Analysis list */
    #pv-list { max-height: 300px; overflow-y: auto; padding: 0; list-style: none; margin: 4px 0; }
    #pv-list li { padding: 2px 4px; cursor: pointer; }
    #pv-list li:hover { background: #eef; }
    #pv-list .pv-header { font-weight: bold; }
  </style>
</head>
<body>
  <h1>Mitch's Sigma Chess</h1>

  <div id="game-options">
    <label>Game Mode:</label>
    <select id="modeSelect">
      <option value="twoplayer">Two Player</option>
      <option value="stockfish">Play Against Stockfish</option>
      <option value="losing">Losing Mode</option>
      <option value="enginevengine">Engine vs Engine</option>
      <option value="setup">Setup Position</option>
      <option value="analysis">Analysis Mode</option>
    </select>
  </div>

  <div id="board-container">
    <div id="chessboard"></div>
    <div id="analysis-panel">
      <div>
        <button id="stopAnalysis" disabled>Stop Analysis</button>
        <button id="hideAnalysis">Hide</button>
      </div>
      <div>
        <label>Depth:</label>
        <select id="depthSelect">
          <option>8</option><option>10</option><option>12</option><option>14</option>
          <option selected>16</option><option>18</option><option>20</option><option>22</option><option>24</option>
        </select>
      </div>
      <div>
        <label>#Lines:</label>
        <button id="decreaseLines">–</button>
        <span id="linesCount">3</span>
        <button id="increaseLines">+</button>
      </div>
      <div>
        <label>Eval:</label> <span id="numericEval">0.00</span>
      </div>
      <ul id="pv-list">
        <li class="pv-header">Principal Variations:</li>
      </ul>
      <hr>
      <div>
        <button id="importFEN">Import FEN</button>
        <button id="importPGN">Import PGN</button>
      </div>
      <div>
        <button id="setupPosition">Setup Position</button>
        <button id="playPosition">Play Position</button>
      </div>
    </div>
  </div>

  <div id="status"></div>
  <div id="version">v.1.8</div>

  <!-- chess.js for game logic -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
  <script>
    // --- Globals ---
    const game = new Chess();
    let boardDiv = document.getElementById('chessboard');
    let selectedSquare = null;
    let mode = 'twoplayer';
    let humanColor = 'w';
    let customFEN = null;

    // Analysis engine
    let engine = null;
    let isAnalyzing = false;

    // --- Board Setup ---
    const files = ['a','b','c','d','e','f','g','h'];

    function createBoard() {
      const tbl = document.createElement('table');
      for (let r = 8; r >= 1; r--) {
        const tr = document.createElement('tr');
        for (let f = 0; f < 8; f++) {
          const td = document.createElement('td');
          const sq = files[f] + r;
          td.id = sq;
          td.className = ((f + r) % 2) ? 'light' : 'dark';
          td.addEventListener('click', onCellClick);
          tr.appendChild(td);
        }
        tbl.appendChild(tr);
      }
      boardDiv.innerHTML = '';
      boardDiv.appendChild(tbl);
    }

    function drawBoard() {
      const b = game.board();
      for (let r = 8; r >= 1; r--) {
        for (let f = 0; f < 8; f++) {
          const sq = files[f] + r;
          const td = document.getElementById(sq);
          const piece = b[8-r][f];
          td.textContent = piece ? unicode(piece) : '';
          td.classList.remove('selected');
        }
      }
      updateStatus();
    }

    function unicode(p) {
      const map = {
        p:{w:'♙',b:'♟'},
        r:{w:'♖',b:'♜'},
        n:{w:'♘',b:'♞'},
        b:{w:'♗',b:'♝'},
        q:{w:'♕',b:'♛'},
        k:{w:'♔',b:'♚'}
      };
      return map[p.type][p.color];
    }

    // --- Status ---
    function updateStatus() {
      let s = '';
      if (game.in_checkmate()) {
        s = 'Game over: ' + (game.turn()==='w' ? 'Black' : 'White') + ' wins.';
      } else if (game.in_draw()) {
        s = 'Game over: drawn.';
      } else {
        s = (game.turn()==='w' ? 'White' : 'Black') + ' to move.';
        if (game.in_check()) s += ' Check!';
      }
      document.getElementById('status').textContent = s;
    }

    // --- Cell click / move ---    
    function onCellClick(e) {
      const sq = e.target.id;
      if (mode==='analysis') {
        // In analysis/setup, let user lay pieces
        boardSetup[sq] = selectedPalettePiece;
        drawSetupBoard();
        return;
      }
      if (mode==='enginevengine') return; // no human moves
      if (!selectedSquare) {
        const pc = game.get(sq);
        if (!pc || pc.color !== game.turn()) return;
        if ((mode==='stockfish'||mode==='losing') && pc.color!==humanColor) return;
        selectedSquare = sq;
        e.target.classList.add('selected');
      } else {
        if (sq===selectedSquare) {
          e.target.classList.remove('selected');
          selectedSquare = null;
          return;
        }
        // handle promotion
        let promo='q';
        const pc = game.get(selectedSquare);
        if (pc && pc.type==='p' &&
           ((pc.color==='w'&&sq.endsWith('8'))||(pc.color==='b'&&sq.endsWith('1')))) {
          const c = prompt('Promote to (q,r,b,n):','q');
          if (c && 'qrbn'.includes(c.toLowerCase())) promo=c.toLowerCase();
        }
        const mv = game.move({from:selectedSquare, to:sq, promotion:promo});
        if (!mv) alert('Invalid');
        selectedSquare = null;
        drawBoard();
        if ((mode==='stockfish'||mode==='losing') && !game.game_over() && game.turn()!==humanColor) {
          setTimeout(() => {
            if (mode==='stockfish') {
              const diff = +document.getElementById('depthSelect').value;
              askEngineMove(diff);
            } else {
              const depth = +document.getElementById('depthSelect').value;
              chooseWorst(depth).then(mv2=>{ if(mv2) game.move(mv2); drawBoard(); });
            }
          }, 200);
        }
      }
    }

    // --- Mode switch ---
    document.getElementById('modeSelect').addEventListener('change', () => {
      mode = document.getElementById('modeSelect').value;
      document.getElementById('analysis-panel').style.display =
        mode==='analysis' ? 'block' : 'none';
      if (mode==='analysis') startAnalysis();
      else stopAnalysis();
      resetGame();
    });

    // --- Engine init ---
    function initEngine() {
      if (engine) engine.terminate();
      engine = new Worker('stockfish.js');
      engine.onmessage = onEngineMsg;
      engine.postMessage('uci');
    }

    // --- Ask best move ---
    function askEngineMove(depth=16) {
      engine.postMessage('ucinewgame');
      engine.postMessage('position fen ' + game.fen());
      engine.postMessage('go depth ' + depth);
    }

    // --- Evaluate worst move ---
    function evaluateFen(fen, depth) {
      return new Promise(r => {
        const w = new Worker('stockfish.js');
        let score = null;
        w.onmessage = e => {
          const line = e.data;
          if (line.includes('score cp')) {
            const m = line.match(/score cp (-?\d+)/);
            if (m) score = +m[1];
          }
          if (line.startsWith('bestmove')) {
            w.terminate();
            r(score);
          }
        };
        w.postMessage('uci');
        setTimeout(()=>{
          w.postMessage('position fen ' + fen);
          w.postMessage('go depth ' + depth);
        },200);
      });
    }
    function chooseWorst(depth=16) {
      const moves = game.moves({verbose:true});
      const evals = moves.map(m=>{
        const c = new Chess(game.fen());
        c.move(m);
        return evaluateFen(c.fen(), depth).then(sc=>({move:m, score:sc}));
      });
      return Promise.all(evals).then(arr=>{
        return arr.reduce((a,b)=>b.score>a.score?b:a).move;
      });
    }

    // --- Analysis panel ---
    document.getElementById('stopAnalysis').onclick = stopAnalysis;
    document.getElementById('hideAnalysis').onclick = () => {
      document.getElementById('analysis-panel').style.display = 'none';
      stopAnalysis();
    };
    document.getElementById('increaseLines').onclick = ()=>{ changeLines(1); };
    document.getElementById('decreaseLines').onclick = ()=>{ changeLines(-1); };
    document.getElementById('depthSelect').onchange = ()=>{ if(isAnalyzing) sendAnalysis(); };

    let pvCount = 3;
    function changeLines(d) {
      pvCount = Math.min(10, Math.max(1, pvCount + d));
      document.getElementById('linesCount').textContent = pvCount;
      if (isAnalyzing) sendAnalysis();
    }

    function startAnalysis() {
      initEngine();
      isAnalyzing = true;
      document.getElementById('stopAnalysis').disabled = false;
      sendAnalysis();
    }
    function stopAnalysis() {
      isAnalyzing = false;
      document.getElementById('stopAnalysis').disabled = true;
      if (engine) engine.postMessage('stop');
    }

    function sendAnalysis() {
      engine.postMessage('ucinewgame');
      engine.postMessage('position fen ' + game.fen());
      engine.postMessage('setoption name MultiPV value ' + pvCount);
      engine.postMessage('setoption name UCI_AnalyseMode value true');
      const d = +document.getElementById('depthSelect').value;
      engine.postMessage('go depth ' + d);
    }

    function onEngineMsg(e) {
      const line = e.data;
      if (!line.startsWith('info')) return;
      const t = line.split(' ');
      const mpvI = t.indexOf('multipv');
      const scI  = t.indexOf('score');
      const pvI  = t.indexOf('pv');
      if (mpvI>-1 && scI>-1 && pvI>-1) {
        const mpv = +t[mpvI+1];
        const cp  = +t[scI+2];
        const moves = t.slice(pvI+1);
        if (mpv===1) {
          document.getElementById('numericEval')
            .textContent = (cp>=0?'+':'')+(cp/100).toFixed(2);
        }
        updatePV(mpv, cp, moves);
      }
    }

    function updatePV(num, cp, moves) {
      const ul = document.getElementById('pv-list');
      let li = ul.querySelector(`li[data-pv="${num}"]`);
      if (!li) {
        li = document.createElement('li');
        li.dataset.pv = num;
        li.onclick = ()=>{ playLine(moves); };
        ul.appendChild(li);
      }
      li.textContent = `${num}. ${moves.join(' ')} (${(cp/100).toFixed(2)})`;
    }

    function playLine(moves) {
      game.reset();
      moves.forEach(mv=>game.move(mv));
      drawBoard();
    }

    // --- Import/Setup/Play ---
    document.getElementById('importFEN').onclick = ()=>{
      const fen = prompt('Paste FEN:');
      if (fen && game.load(fen)) drawBoard();
      else alert('Invalid FEN');
    };
    document.getElementById('importPGN').onclick = ()=>{
      const pgn = prompt('Paste PGN:');
      try { game.load_pgn(pgn); drawBoard(); }
      catch { alert('Invalid PGN'); }
    };
    document.getElementById('setupPosition').onclick = ()=>{
      document.getElementById('modeSelect').value='setup';
      document.getElementById('modeSelect').dispatchEvent(new Event('change'));
    };
    document.getElementById('playPosition').onclick = ()=>{
      customFEN = game.fen();
      document.getElementById('modeSelect').value='twoplayer';
      document.getElementById('modeSelect').dispatchEvent(new Event('change'));
    };

    // --- Setup Mode ---
    let boardSetup = {}, selectedPalettePiece = '';
    function initializeSetupBoard(){
      boardSetup={};
      for(let r=1;r<=8;r++) for(let f of files) boardSetup[f+r]='';
      drawSetup();
    }
    function drawSetup(){
      for(let r=8;r>=1;r--){
        for(let f=0;f<8;f++){
          const sq = files[f]+r, td=document.getElementById(sq);
          const code = boardSetup[sq];
          td.textContent = code ? unicode({type:code[1],color:code[0]}) : '';
        }
      }
    }
    function makeFEN(turn){
      const parts=[];
      for(let r=8;r>=1;r--){
        let row='',empty=0;
        for(let f=0;f<8;f++){
          const c=boardSetup[files[f]+r];
          if(!c) empty++;
          else{
            if(empty){row+=empty;empty=0;}
            let L=c[1];
            row += (c[0]==='w'?L.toUpperCase():L.toLowerCase());
          }
        }
        if(empty) row+=empty;
        parts.push(row);
      }
      return parts.join('/')+' '+turn+' - - 0 1';
    }

    // --- Reset Game ---
    function resetGame() {
      if (customFEN && mode!=='setup')
        game.load(customFEN);
      else
        game.reset();
      createBoard(); drawBoard();
      if (mode==='enginevengine') setTimeout(runEngineVsEngine,250);
      if (mode==='setup') initializeSetupBoard();
    }

    // === On load ===
    window.onload = ()=>{
      createBoard(); drawBoard();
      updateStatus();
      document.getElementById('modeSelect').value='twoplayer';
    };
  </script>
</body>
</html>
