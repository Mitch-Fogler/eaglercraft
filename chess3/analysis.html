<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Sigma Chess Analysis</title>
  <style>
    body { margin:0; font-family:Arial,sans-serif; }
    /* --- Toolbar up top --- */
    .analysis-toolbar {
      display:flex; align-items:center; gap:8px;
      padding:8px; background:#fafafa; border-bottom:1px solid #ddd;
    }
    .analysis-toolbar input,
    .analysis-toolbar textarea,
    .analysis-toolbar button {
      font-size:14px; padding:4px; border:1px solid #ccc;
    }

    /* --- Setup palette --- */
    #setup-controls {
      display:flex; align-items:center; gap:16px;
      padding:8px; background:#f5f5f5; border-bottom:1px solid #ddd;
    }
    #piece-palette button {
      font-size:20px; margin:2px; padding:4px 8px; cursor:pointer;
    }
    #setup-controls select,
    #setup-controls button {
      font-size:14px; padding:4px;
    }

    /* --- Main container: board + analysis --- */
    .analysis-container {
      display:flex; height:calc(100vh - 112px); /* toolbar + setup height */
    }
    .board-pane {
      flex:3; display:flex; justify-content:center; align-items:center;
      background:#fff;
    }
    .analysis-pane {
      flex:2; display:flex; flex-direction:column;
      border-left:1px solid #ddd; overflow:hidden;
    }

    /* --- PV controls + list + graph --- */
    #pvControls {
      display:flex; align-items:center; gap:8px;
      padding:8px; background:#fafafa; border-bottom:1px solid #ddd;
    }
    #pvList {
      flex:1; overflow-y:auto; padding:8px;
      font-family:monospace; font-size:14px;
    }
    #evalGraph {
      width:100%; height:100px; border-top:1px solid #ddd;
    }

    /* --- Chessboard styling (same as main) --- */
    #chessboard table { border-collapse:collapse; }
    #chessboard td {
      width:60px; height:60px;
      text-align:center; vertical-align:middle;
      font-size:42px; cursor:pointer; user-select:none;
    }
    .light { background:#f0d9b5; }
    .dark  { background:#b58863; }
    .selected { outline:3px solid red; }
  </style>
</head>
<body>

  <!-- FEN/PGN toolbar -->
  <div class="analysis-toolbar">
    <label>FEN:</label>
    <input type="text" id="fenInput" placeholder="Enter FEN…"/>
    <button id="importFen">Import</button>

    <label>PGN:</label>
    <textarea id="pgnInput" placeholder="Paste PGN…"></textarea>
    <button id="importPgn">OK</button>
  </div>

  <!-- Setup editor controls -->
  <div id="setup-controls">
    <div id="piece-palette"></div>

    <label>Turn:</label>
    <select id="turnSelect">
      <option value="w">White to move</option>
      <option value="b">Black to move</option>
    </select>

    <button id="finishSetupButton">Apply Position</button>
  </div>

  <!-- Board + Analysis Pane -->
  <div class="analysis-container">
    <div class="board-pane">
      <div id="chessboard"></div>
    </div>
    <div class="analysis-pane">
      <div id="pvControls">
        <button id="lessLines">–</button>
        <span>Lines</span>
        <button id="moreLines">+</button>
      </div>
      <div id="pvList"></div>
      <canvas id="evalGraph"></canvas>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
  <script src="stockfish.js"></script>
  <script>
  // === SETUP & DRAWING ===
  const game = new Chess();
  const files = ['a','b','c','d','e','f','g','h'];
  let boardSetup = {}, selectedPalettePiece = '', selectedSquare = null;
  let multiPV = 1, cpHistory = [];

  function createBoard(){
    const bd = document.getElementById('chessboard');
    const tbl = document.createElement('table');
    for(let i=0;i<8;i++){
      const tr = document.createElement('tr'), rank = 8 - i;
      for(let j=0;j<8;j++){
        const td = document.createElement('td');
        td.id = files[j] + rank;
        td.className = (i+j)%2 ? 'light' : 'dark';
        td.addEventListener('click', onCellClick);
        tr.append(td);
      }
      tbl.append(tr);
    }
    bd.innerHTML = ''; bd.append(tbl);
  }

  function getUnicode(piece){
    const m = { p:{w:'♙',b:'♟'}, r:{w:'♖',b:'♜'}, n:{w:'♘',b:'♞'},
                b:{w:'♗',b:'♝'}, q:{w:'♕',b:'♛'}, k:{w:'♔',b:'♚'} };
    return m[piece.type][piece.color];
  }

  function drawSetupBoard(){
    for(let r=8;r>=1;r--){
      for(let j=0;j<8;j++){
        const sq = files[j] + r;
        const td = document.getElementById(sq);
        const code = boardSetup[sq] || '';
        if(code){
          td.innerHTML = getUnicode({type:code[1], color:code[0]});
          td.style.color = code[0]==='b' ? '#666' : '';
        } else {
          td.innerHTML = '';
        }
        td.classList.remove('selected');
      }
    }
  }

  function drawBoard(){
    const b = game.board();
    for(let i=0;i<8;i++){
      const rank = 8 - i;
      for(let j=0;j<8;j++){
        const sq = files[j] + rank, td = document.getElementById(sq);
        const pc = b[i][j];
        if(pc){
          td.innerHTML = getUnicode(pc);
          td.style.color = (pc.color==='b') ? '#666' : '';
        } else td.innerHTML = '';
        td.classList.remove('selected');
      }
    }
  }

  // === PIECE PALETTE ===
  function createPiecePalette(){
    const pal = document.getElementById('piece-palette');
    const items = [
      {lbl:'Clear',code:''},
      {lbl:'♙',code:'wp'},{lbl:'♘',code:'wn'},{lbl:'♗',code:'wb'},
      {lbl:'♖',code:'wr'},{lbl:'♕',code:'wq'},{lbl:'♔',code:'wk'},
      {lbl:'♟',code:'bp'},{lbl:'♞',code:'bn'},{lbl:'♝',code:'bb'},
      {lbl:'♜',code:'br'},{lbl:'♛',code:'bq'},{lbl:'♚',code:'bk'}
    ];
    pal.innerHTML='';
    items.forEach(it=>{
      const b = document.createElement('button');
      b.innerText = it.lbl;
      b.onclick = ()=> selectPalettePiece(it.code);
      pal.append(b);
    });
    selectPalettePiece('');
  }

  function selectPalettePiece(code){
    selectedPalettePiece = code;
    Array.from(document.getElementById('piece-palette').children)
      .forEach(b=>{
        b.style.border = (code && b.innerText === getUnicode({type:code[1],color:code[0]})) 
                         || (!code && b.innerText==='Clear')
          ? '2px solid red'
          : '';
      });
  }

  // === CELL CLICK HANDLER ===
  function onCellClick(e){
    const sq = e.currentTarget.id;
    // in setup: place/remove piece
    if(selectedPalettePiece !== null){
      boardSetup[sq] = selectedPalettePiece;
      drawSetupBoard();
      return;
    }
  }

  function initializeSetupBoard(){
    boardSetup = {};
    for(let r=1;r<=8;r++) for(let f of files) boardSetup[f+r] = '';
    drawSetupBoard();
  }

  function finishSetup(){
    // build FEN from boardSetup + turn
    const turn = document.getElementById('turnSelect').value;
    const parts = [];
    for(let r=8;r>=1;r--){
      let row='', empty=0;
      for(let f of files){
        const c = boardSetup[f+r];
        if(!c) empty++;
        else {
          if(empty){ row+=empty; empty=0; }
          let L = c[1];
          row += c[0]==='w' ? L.toUpperCase() : L.toLowerCase();
        }
      }
      if(empty) row+=empty;
      parts.push(row);
    }
    const fen = parts.join('/') + ' ' + turn + ' - - 0 1';
    document.getElementById('fenInput').value = fen;
    game.load(fen);
    drawBoard();
    analyzeCurrentPosition();
  }

  // === STOCKFISH INTEGRATION & ANALYSIS ===
  const stockfish = new Worker('stockfish.js');
  stockfish.postMessage('uci');
  stockfish.onmessage = (e) => {
    const m = e.data;
    if(m.startsWith('info')){
      // parse PV lines, scores, build pvList & cpHistory
      const parts = m.split(' ');
      const mpv = parts.indexOf('multipv')>-1 ? +parts[parts.indexOf('multipv')+1] : 1;
      const scIdx = parts.indexOf('score');
      if(scIdx>-1){
        const cp = +parts[scIdx+2];
        if(mpv===1){ // use pv1 to update graph
          cpHistory.push(cp);
          updateEvalGraph();
        }
      }
      if(m.includes('pv ') && mpv <= multiPV){
        renderPVs();  // re-render all PVs from last batch
      }
    }
  };

  function analyzeCurrentPosition(){
    cpHistory = [];
    document.getElementById('pvList').innerHTML = '';
    stockfish.postMessage(`setoption name MultiPV value ${multiPV}`);
    stockfish.postMessage('position fen ' + game.fen());
    stockfish.postMessage('go depth 16');
  }

  document.getElementById('importFen').onclick = () => {
    const fen = document.getElementById('fenInput').value.trim();
    if(game.load(fen)) { drawBoard(); analyzeCurrentPosition(); }
    else alert('Invalid FEN');
  };

  // (Optionally wire PGN import, parse with chess.js, then call analyzeCurrentPosition)

  document.getElementById('moreLines').onclick = () => {
    multiPV = Math.min(multiPV+1,5);
    analyzeCurrentPosition();
  };
  document.getElementById('lessLines').onclick = () => {
    multiPV = Math.max(multiPV-1,1);
    analyzeCurrentPosition();
  };

  function renderPVs(){
    // Naïve: scan last stockfish outputs buffer for each multipv
    // For brevity, assume you collect them in an array `lastPVs[]`
    // then do:
    // document.getElementById('pvList').innerHTML = lastPVs.map(
    //   pv=>`<div>${pv}</div>`
    // ).join('');
  }

  function updateEvalGraph(){
    const ctx = document.getElementById('evalGraph').getContext('2d');
    const w = ctx.canvas.width, h = ctx.canvas.height;
    ctx.clearRect(0,0,w,h);
    if(cpHistory.length<2) return;
    ctx.beginPath();
    cpHistory.forEach((cp,i)=>{
      const x = (i/(cpHistory.length-1))*w;
      const y = h/2 - (cp/1000)*(h/2);
      i===0 ? ctx.moveTo(x,y) : ctx.lineTo(x,y);
    });
    ctx.stroke();
  }

  // === INIT ===
  createBoard();
  createPiecePalette();
  initializeSetupBoard();
  drawBoard();
  </script>
</body>
</html>
